SELECT:
select * from customers where id = 1 order by first-name

aliases:
select first-name , last-name , average * 10 as model from customers

distinct:
# it would not assess and show duplicate rows
select distinct state from customers 

(<,> ,!= , <>)operator :
select * from customers where birth-date > "2020-10-2"

(and,or) operator:
select * from customers where (points > 1000 and state = "VA") or state = "CA"
select * from order where order-item = 1 and quantity * price > 30 

in operator :
where state = "VA" or state = "CA" or state = "ML" 
-----> where state in ("CA","VA","ML")

between operator :
select * from customers where points between 1000 and 30000
select * from customers where birth-date between "1990-10-10" and "2020-01-01"

like operator : 
% represents any number of characters
_ represents single character

select * from customers where 
address like "%abad%" or address like "%rey" or phone like "%9"

regex :
select * from customers where regexp "[a-h]e"

is null :
select * from customers where phone is null / is not null

order by :
select * , quantity * price as total-price order by total-price DESC

limit offset :
select * from customers order by balance limit 3 offset 5 (5,3)

-----------------------------------------------------------------
JOIN:

inner join :
select * from students join parents on students.Id = parents.studentId

join from another database :
select * from students s join anotherDatabase.Parents ap on s.id = ap.id

select * from students join parents on students.id = parents.student_id

## "USE" said that on which database you are working --> use public \n select * from .....

join a table with itself :
select e.firstname , e.lastname , e.reports_to , m.employeeId as manager from employee e join employee m on e.report_to = m.employee_id

join on multiple tables :
select * from orders o
join customers c on o.customer_id = c.customer_id
join status s on o.status_id = s.status_id

compound join item :
## most of the time we use it when we do not have primary keys or 1 primary key
select * from order_item oi
join order_items_notes oin
on oi.product_id = oin.product_id and oi.order_id = oin.oi.order_id

outer join (left/right):
## it's fetch all data's from right or left table where ON condition happen or not
select * from customers c left join orders o on c.customer_id = o.customer_id (left --> customer)
select * from customers c right join orders o on c.customer_id = o.customer_id (right --> orders)

natural join :
## query provide on condition automatically
select * from customers natural join orders

cross join :
## it mapped all rows in customer to orders
select * from customers cross join orders == select * from customers , orders

union :
## combine 2 queries with each other
select * , "Active" as status from orders where order_date >= '2020-01-01' union select * , 'Archived' as status
from orders where order_date < '2020-01-01'
## they have to same columns
select x column from customers union select x column from orders

---------------------------------------------------------------------------------------------
INSERT :

insert :
insert into customers (lastname , firstname ,phone) values ("Valizadeh", "Aras" , "091244874192")

insert multiple rows :
insert into customers (lastname) values ("Moraveji"),("Valizadeh"),("Rostambeygi")

copy a table :
create table orders_copy as select * from orders (after AS is a sub query)
(just specific rows) create table copy as select * from orders where points > 40 (after AS is a sub query)

update a row in table :
update customers set payment_total = invoice_total * 0.5 where firstname = "Aras"
update customers set point = point + 50 where born-date < '2020-01-01'

update multiple rows in table :
update customers set ... where id in (1,2,3,4,5,9) / id between 100 and 400
## with sub query --> update customers set .... where id in (select customer_id from customers where state in ("CA","VF","ML"))

delete :
delete a row :
delete from orders where order_id = (select * from clients where name = "example")

aggregate functions :
## these functions will not consider null values
select max(total_income) , min(total_income) , avg(total-income * 1.1) , sum(...) , count(...) from employee
## if you want to consider all data as well null values --> count(*) as all_records

group by :
select client_id , sum(sales) as total_sales from customers group by client_id
select state , city , sum (sales) as total_sales from invoices join clients group by state , city

order of sql commands : select - from - join - where - group by - having

having :
## when we use group by we can not use that element we grouped it , so we have to use having command after group by cluase 
## you can mention columns of select in the group by but you can use all of columns in where 
select city , state , sum (sales) as total_sales from invoices join clients group by client_id , state having total_sales > 5000

with roll up (mysql) :
## it used when we want to set a row that represnts our function without considering group by clause
select city , sum (sales) as total_sales from invoices group by city ,state with rollup


sub query :
## sub queries can be a single value or a table :
select * from customers where salary > (select avg(salary) from customer)
## sub queries has more readablity and less performance 

All :
## is used to determine the max value of a rangs of number 
select * from employees where salary > All (select invoice_total from invoices )

Any :
## is used set equality with multiple values
select * from customers where customer_id = Any (select customer_id from invoices group by customer_id having count(*) >= 2)

correlated sub queries :
## make a refrence which is in out of sub queries and is used inside of sub query 
select * from employee e where salary > (select AVG(salary) from employee where e.office_id = office_id)

Exist :
## is used when we want to know that a refrence in primary query is exist in sub query 
select * from customers c where Exist (select customer_id from invoices where customer_id = c.id)

sub query in the select clause :
select invoice_id , invoice_total , (select AVG(invoice_total) from invoices) from invoices